--information:${INFO} ${VERSION} by ${AUTHOR}
--label:変形

---$track:曲率
---min=-10000
---max=10000
---step=0.01
local curvature = 0

---$track:割合
---min=0
---max=100
---step=0.01
local rate = 0

---$track:分割数
---min=1
---max=5000
---step=1
local div = 16

---$track:細分化
---min=1
---max=10
---step=1
local subdiv = 1

---$check:アンカー表示
local visibleAnchor = 1

---$check:始点
local startMode = 1

---$check:終点
local endMode = 1

---$check:破綻回避
local collapse = 1

---$select:中心
---オリジナルの中心=0
---変形後の中心=1
---赤マーカー=2
---青マーカー=3
---緑マーカー=4
---マゼンダマーカー=5
---シアンマーカー=6
local centerMode = 0

---$value:アンカー
local pos = {0,100,0,-100}

--[[
  曲率: 値が0から離れるほど曲がる
  割合: 始点と終点の間のどこを中心にするか
  分割数: 始点と終点の間をどれだけ分割するか
  細分化: 描画時の細分化度
  アンカー表示: アンカーと元画像を表示する
  始点: 始点より外側を描画する
  終点: 終点より外側を描画する
  破綻回避: 曲率が大きいときの破綻を回避する
  中心: 中心座標をどこにするか
  アンカー: アンカー座標
]]

local B = require("KaroterraBend")
local markerSize = 25

if #pos < 4 then
  pos = {pos[1] or 0, pos[2] or 0, pos[3] or 0, pos[4] or 0}
end
_ = obj.setanchor("pos", 2)

local curvature = curvature / 10000
local radius = 1 / curvature
local rate = rate / 100
local div = math.floor(div)
local visibleAnchor = visibleAnchor ~= 0
local startMode = startMode or 1
local endMode = endMode or 1
local centerMode = centerMode or 0
local collapse = collapse or 1
local subdiv = math.max(math.floor(subdiv or 1), 1)

local w, h = obj.getpixel()
local ancS = {B.clamp(pos[1], -w/2, w/2), B.clamp(pos[2], -h/2, h/2)}
local ancE = {B.clamp(pos[3], -w/2, w/2), B.clamp(pos[4], -h/2, h/2)}
local ancC = {(1-rate)*ancS[1] + rate*ancE[1], (1-rate)*ancS[2] + rate*ancE[2]}
local curvS, curvE = ancS, ancE

local ancRad = math.atan2(ancE[2] - ancS[2], ancE[1] - ancS[1])
local ancDist = math.sqrt((ancE[1]-ancS[1])^2 + (ancE[2]-ancS[2])^2)
local curvSRad = ancRad - math.pi / 2
local curvERad = ancRad - math.pi / 2

local srcS, srcE, srcI = B.createSrc(ancS, ancE, w, h, div)
local dstS, dstE, dstI = {}, {}, {}

-- 変換
if curvature == 0 then
  for i = 1, #srcI do
    dstI[i] = {}
    for j = 1, #srcI[i], 2 do
      dstI[i][j] = srcI[i][j] - w/2
      dstI[i][j+1] = srcI[i][j+1] - h/2
    end
  end
else
  local curvRad = ancRad + math.pi / 2
  local curvC = {ancC[1] + radius*math.cos(curvRad), ancC[2] + radius*math.sin(curvRad)}
  curvSRad = curvRad - math.pi - rate * ancDist / radius
  curvERad = curvRad - math.pi + (1-rate) * ancDist / radius
  curvS = {curvC[1] + radius*math.cos(curvSRad), curvC[2] + radius*math.sin(curvSRad)}
  curvE = {curvC[1] + radius*math.cos(curvERad), curvC[2] + radius*math.sin(curvERad)}
  local c, s = math.cos(-ancRad+math.pi/2), math.sin(-ancRad+math.pi/2)

  for i = 1, #srcI do
    dstI[i] = {}
    for j = 1, #srcI[i], 2 do
      local x, y = srcI[i][j] - w/2, srcI[i][j+1] - h/2
      local u, v = x-ancS[1], y-ancS[2]
      u, v = u*c-v*s, u*s+v*c
      local r = radius + u
      local rad = curvSRad + v / radius
      dstI[i][j] = curvC[1] + r * math.cos(rad)
      dstI[i][j+1] = curvC[2] + r * math.sin(rad)
    end
    if collapse == 1 then
      srcI[i], dstI[i] = B.fixCollapse(srcI[i], dstI[i])
    end
  end
end

for i = 1, #srcS do
  dstS[i] = B.transformEdge(srcS[i], ancS, curvS, curvSRad-ancRad+math.pi/2, w, h)
end
for i = 1, #srcE do
  dstE[i] = B.transformEdge(srcE[i], ancE, curvE, curvERad-ancRad+math.pi/2, w, h)
end

-- キャンバス
local range = {dstI[1][1],dstI[1][1], dstI[1][2],dstI[1][2]}
B.calcRange(dstI, range)
if startMode == 1 then B.calcRange(dstS, range) end
if endMode == 1 then B.calcRange(dstE, range) end
if visibleAnchor then
  range[1] = math.min(range[1],-w/2) - markerSize/2
  range[2] = math.max(range[2], w/2) + markerSize/2
  range[3] = math.min(range[3],-h/2) - markerSize/2
  range[4] = math.max(range[4], h/2) + markerSize/2
end
local ox, oy = (range[2] + range[1]) / 2, (range[4] + range[3]) / 2

-- 描画
obj.setoption("drawtarget", "tempbuffer", range[2]-range[1], range[4]-range[3])

if visibleAnchor then
  obj.draw(-ox,-oy,0, 1, 0.5)
end

obj.setoption("blend", "alpha_add2")
if startMode == 1 then
  for i = 1, #srcS do B.drawpoly(obj, dstS[i], ox, oy, srcS[i]) end
end
if subdiv > 1 then
  for i = 1, #srcI do B.subdivDrawpoly(obj, dstI[i], ox,oy, srcI[i], subdiv) end
else
  for i = 1, #srcI do B.drawpoly(obj, dstI[i], ox, oy, srcI[i]) end
end
if endMode == 1 then
  for i = 1, #srcE do B.drawpoly(obj, dstE[i], ox, oy, srcE[i]) end
end

-- アンカー表示
if visibleAnchor then
  B.drawMarker(obj, curvS[1]-ox, curvS[2]-oy, 0xff00ff, markerSize)
  B.drawMarker(obj, curvE[1]-ox, curvE[2]-oy, 0x00ffff, markerSize)
  B.drawMarker(obj, ancC[1]-ox, ancC[2]-oy, 0x00ff00, markerSize)
  B.drawMarker(obj, ancS[1]-ox, ancS[2]-oy, 0xff0000, markerSize)
  B.drawMarker(obj, ancE[1]-ox, ancE[2]-oy, 0x0000ff, markerSize)
end

obj.setoption("drawtarget", "framebuffer")
obj.load("tempbuffer")
if centerMode == 1 then
  obj.ox = obj.ox + ox
  obj.oy = obj.oy + oy
elseif centerMode == 2 then
  obj.ox = obj.ox + ancS[1]
  obj.oy = obj.oy + ancS[2]
  obj.cx = obj.cx - ox + ancS[1]
  obj.cy = obj.cy - oy + ancS[2]
elseif centerMode == 3 then
  obj.ox = obj.ox + ancE[1]
  obj.oy = obj.oy + ancE[2]
  obj.cx = obj.cx - ox + ancE[1]
  obj.cy = obj.cy - oy + ancE[2]
elseif centerMode == 4 then
  obj.ox = obj.ox + ancC[1]
  obj.oy = obj.oy + ancC[2]
  obj.cx = obj.cx - ox + ancC[1]
  obj.cy = obj.cy - oy + ancC[2]
elseif centerMode == 5 then
  obj.ox = obj.ox + curvS[1]
  obj.oy = obj.oy + curvS[2]
  obj.cx = obj.cx - ox + curvS[1]
  obj.cy = obj.cy - oy + curvS[2]
elseif centerMode == 6 then
  obj.ox = obj.ox + curvE[1]
  obj.oy = obj.oy + curvE[2]
  obj.cx = obj.cx - ox + curvE[1]
  obj.cy = obj.cy - oy + curvE[2]
else
  obj.cx = obj.cx - ox
  obj.cy = obj.cy - oy
end
